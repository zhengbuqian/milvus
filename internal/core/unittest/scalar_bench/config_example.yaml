# Scalar Filter Benchmark Configuration Example
# This file demonstrates how to use text proto expressions in YAML

data_configs:
  - name: "uniform_int64_1m"
    segment_size: 1000000
    data_type: "INT64"
    distribution: "UNIFORM"
    cardinality: 100000
    null_ratio: 0.0

  - name: "normal_float_1m"
    segment_size: 1000000
    data_type: "FLOAT"
    distribution: "NORMAL"
    cardinality: 50000
    null_ratio: 0.1

  - name: "zipf_varchar_1m"
    segment_size: 1000000
    data_type: "VARCHAR"
    distribution: "ZIPF"
    cardinality: 10000
    null_ratio: 0.05

index_configs:
  - name: "no_index"
    type: "NONE"
    params: {}

  - name: "bitmap_index"
    type: "BITMAP"
    params:
      chunk_size: "8192"

  - name: "inverted_index"
    type: "INVERTED"
    params:
      chunk_size: "4096"

# Expression templates using text proto format
# These are complete text proto strings that will be parsed directly
expr_templates:
  - name: "greater_than_5000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          unary_range_expr {
            column_info {
              field_id: 101
              data_type: Int64
            }
            op: GreaterThan
            value { int64_val: 5000 }
          }
        }
      }

  - name: "less_than_3000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          unary_range_expr {
            column_info {
              field_id: 101
              data_type: Int64
            }
            op: LessThan
            value { int64_val: 3000 }
          }
        }
      }

  - name: "equal_5000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          unary_range_expr {
            column_info {
              field_id: 101
              data_type: Int64
            }
            op: Equal
            value { int64_val: 5000 }
          }
        }
      }

  - name: "range_1000_to_3000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          binary_range_expr {
            column_info {
              field_id: 101
              data_type: Int64
            }
            lower_inclusive: true
            upper_inclusive: true
            lower_value { int64_val: 1000 }
            upper_value { int64_val: 3000 }
          }
        }
      }

  - name: "in_specific_values"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          term_expr {
            column_info {
              field_id: 101
              data_type: Int64
            }
            values { int64_val: 100 }
            values { int64_val: 200 }
            values { int64_val: 300 }
            values { int64_val: 400 }
            values { int64_val: 500 }
          }
        }
      }

  - name: "string_prefix_user"
    text_proto: |
      output_field_ids: 102
      query {
        predicates {
          unary_range_expr {
            column_info {
              field_id: 102
              data_type: VarChar
            }
            op: PrefixMatch
            value { string_val: "user_" }
          }
        }
      }

  - name: "complex_and_2000_to_8000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          binary_expr {
            op: LogicalAnd
            left {
              unary_range_expr {
                column_info {
                  field_id: 101
                  data_type: Int64
                }
                op: GreaterThan
                value { int64_val: 2000 }
              }
            }
            right {
              unary_range_expr {
                column_info {
                  field_id: 101
                  data_type: Int64
                }
                op: LessThan
                value { int64_val: 8000 }
              }
            }
          }
        }
      }

  - name: "not_equal_5000"
    text_proto: |
      output_field_ids: 101
      query {
        predicates {
          unary_expr {
            op: Not
            child {
              unary_range_expr {
                column_info {
                  field_id: 101
                  data_type: Int64
                }
                op: Equal
                value { int64_val: 5000 }
              }
            }
          }
        }
      }

# Each expression template contains a complete, self-contained text proto
# No parameter substitution is needed - just parse and execute

# Test parameters
test_params:
  warmup_iterations: 10
  test_iterations: 100
  verify_correctness: true
  collect_memory_stats: true