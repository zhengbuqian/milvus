使用 internal/core/run_iwyu.sh 脚本，处理和修复头文件，包括测试文件和业务代码文件。

0. 现在的代码是可以编译的，git工作区也是干净的，之后你只允许叠加新的commit，已有 commit 及之前不准动。
1. iwyu_progress.md 记录了处理的进度。里面有cpp文件的一些记录，你不用管，只处理头文件。每个文件一个 check box,处理好了打 x ，有问题打 ! ，还没处理留空。
2. 写一个python脚本 scan_header.py （如果你发现已经有这个文件，就直接使用，否则如果是你写的这个脚本，请提交到git中）， 脚本的工作：
   2.1 阅读 iwyu_progress.md，记录所有还没有处理的 头文件， 和所有标记 [!] 的 cpp 文件和头文件。
   2.2 扫描 internal/core 中的所有 cpp文件，过滤掉 [!] 标记的cpp文件， 记录剩下每个 cpp 文件包含的所有本项目的头文件列表，跳过 iwyu_progress.md 中记录为 [x] 处理过的头文件和 [!] 标记的cpp文件。
   2.3 然后从前往后选择剩下的cpp文件，当他们include的 internal/core中的没被处理过的头文件加起来超过12个，就返回这一批cpp。比如假设前两个cpp就include 了13个，就处理这两个cpp来实现处理13个头文件的目的。然后之后5个cpp include了14个没处理过的头文件，就再处理这5个cpp，实现处理14个头文件的目的。当然如果哪个cpp文件不贡献新的头文件就不处理它了，我说的头文件仅包含本项目的头文件,不要处理其他代码的头文件。
2. 进入循环：
   2.1 每次先起一个 subagent 通过 iwyu_progress.md 和 上面的脚本，寻找并返回 12 个下一批次需要处理的头文件，以及作为跳板的 cpp 文件。
   2.2 然后再另起一个 subagent 处理这12 个头文件和cpp文件。这个 subagent 的工作包括: 1. 分析、修复这些文件, 2. 如果有任何文件被处理，运行 ./compile.sh compile 确认可以编译， 3. 然后 commit这些修改,之后不再回退所有commit过的文件, 4. 如果有不好处理的文件导致iwyu修复后反而编译失败，不要尝试修复iwyu，而是先跳过这些导致失败的文件并把他们恢复原样，再重新编译确认能编译后把能处理的文件commit。然后在进度文件中给剩下的处理后仍然能编译的文件打x，不能处理的打!。这个进度记录文件和我有的时候会在你处理的过程中更新 iwyu_guide.md 的修改也总是提交到commit里去
3. 每次处理完22个文件后，更新进度文件，并 commit 进度文件。

iwyu分析和处理的时候，倾向于使用include而不是前向声明，可以的话，使用 --no_fwd_decls，除非include会造成循环，只有前向声明能解决。
记得跳过生成的文件，比如.pb.h
iwyu工具支持-j参数批量处理，每次12个文件都记得使用6个并发来一次性批量处理。
在整个处理循环中， 你只应该做循环管理，任何稍微复杂的操作都交给subagent完成。
任意时刻最多同时起一个subagent，不要同时开两个iwyu脚本，不要同时开两个compile.sh脚本，也不要同时开compile.sh和iwyu。

如果你刚刚经历了上下文 compaction， 复习上面的内容。
