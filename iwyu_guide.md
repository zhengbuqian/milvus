使用 internal/core/run_iwyu.sh 脚本，处理和修复cpp文件和头文件，包括测试文件和业务代码文件。

0. 现在的代码是可以编译的，git工作区也是干净的，之后你只允许叠加新的commit，已有 commit e8f340958e 及之前不准动。
1. 先启动一个 subagent 执行这个工作： 用 find 收集和列举 internal/core 中的所有的cpp文件和头文件，包括测试文件和业务代码文件， 写到一个 .md 文件内记录进度， 每个文件一个 check box,处理好了打 x ，有问题打 ! ，还没处理留空。
2. 进入循环：
   2.1 每次先起一个 subagent 阅读我们的进度记录文件，返回 22 个下一批次需要处理的文件，选择文件的规则是： 
       如果还有 cpp 文件没有处理， 先处理 cpp 文件，所有的cpp文件都处理完成之后再处理 .h/.hpp文件。不要在一个批次内混合处理 cpp 和 头文件。也就是 cpp 的最后一个批次处理完后再开始头文件的批次。
       由于 iwyu 无法直接处理 头文件，到了处理头文件的时候，使用这样的方式处理头文件：先列举所有的前面的批次成功处理过的cpp文件，然后从前往后选择，当他们include的 internal/core中的头文件加起来超过22个，就处理这一批cpp。比如假设前两个cpp就include 了23个，就处理这两个cpp来实现处理23个头文件的目的，然后下5个cpp除去处理过的header之外，include了24个，就再处理这5个cpp，实现处理24个头文件的目的。当然如果哪个cpp文件不共享新的头文件就不处理它了，我说的头文件仅包含本项目的头文件,不要处理其他代码的头文件。
   2.2 然后再另起一个 subagent 处理这22 个文件。这个 subagent 的工作包括: 1. 分析、修复这些文件, 2. 如果有任何文件被处理，运行 ./compile.sh compile 确认可以编译， 3. 然后 commit这些修改,之后不再回退所有commit过的文件, 4. 如果有不好处理的文件导致iwyu修复后反而编译失败，不要尝试修复iwyu，而是先跳过这些导致失败的文件并把他们恢复原样，再重新编译确认能编译后把能处理的文件commit。然后在进度文件中给剩下的处理后仍然能编译的文件打x，不能处理的打!。
3. 每次处理完22个文件后，更新进度文件，并 commit 进度文件。

iwyu分析和处理的时候，倾向于使用include而不是前向声明，可以的话，使用 --no_fwd_decls，除非include会造成循环，只有前向声明能解决。
记得跳过生成的文件，比如.pb.h
iwyu工具支持-j参数批量处理，每次22个文件都记得使用11个并发来一次性批量处理。

如果你刚刚经历了上下文 compaction， 复习上面的内容。
